apiVersion: espejote.io/v1alpha1
kind: ManagedResource
metadata:
  annotations:
    syn.tools/description: |
      Manages Roles and RoleBindings based on namespace labels.

      To customize the applied RBAC templates, you can use labels on namespaces to select
      additional template sets. See https://hub.syn.tools/rbac/index.html for details.
  labels:
    app.kubernetes.io/name: espejote-rbac-sync
  name: espejote-rbac-sync
  namespace: syn-espejote
spec:
  applyOptions:
    force: true
  context:
    - name: namespaces
      resource:
        apiVersion: v1
        kind: Namespace
  serviceAccountRef:
    name: espejote-rbac-sync
  template: "local esp = import 'espejote.libsonnet';\nlocal config = import 'lib/espejote-rbac-sync/config.json';\n\
    \nlocal context = esp.context();\n\nlocal activeSetsAnnotation = 'rbac.syn.tools/active-policies';\n\
    \n// Extract the active template sets from the given namespace object,\n// based\
    \ on the annotations applied by this ManagedResource.\nlocal activeTemplateSets(namespace)\
    \ =\n  local rawSet = std.get(std.get(namespace.metadata, 'annotations', {}),\
    \ activeSetsAnnotation, '[]');\n  std.set(std.parseJson(rawSet));\n\n// Extract\
    \ the desired template sets from the given namespace object,\n// Returns an empty\
    \ array if the namespace is in the ignoreNames or ignorePrefixes list.\nlocal\
    \ desiredTemplateSets(namespace) =\n  local objHasLabel(obj, label) =\n    std.objectHas(std.get(obj.metadata,\
    \ 'labels', {}), label);\n\n  // Check if the namespace is ignored by name or\
    \ prefix.\n  local isIgnored(namespace) =\n    std.member(config.ignoreNames,\
    \ namespace.metadata.name) ||\n    std.length(\n      std.filter(\n        function(prefix)\
    \ std.startsWith(namespace.metadata.name, prefix),\n        config.ignorePrefixes\n\
    \      )\n    ) > 0;\n\n  // Template sets based on labels starting with params.labelPrefix.\n\
    \  //   labels:\n  //     set.example.io/airlock: \"\"\n  //     set.example.io/myapp:\
    \ \"\"\n  // would return the template sets `[\"airlock\", \"myapp\"]`.\n  //\
    \ The configured prefix is suffixed with a '/' if it does not already end with\
    \ one.\n  local templateSetsFromLabel =\n    local prefix = if std.endsWith(config.labelPrefix,\
    \ '/') then\n      config.labelPrefix\n    else\n      config.labelPrefix + '/';\n\
    \n    [\n      lbl[std.length(prefix):]\n      for lbl in std.objectFields(std.get(namespace.metadata,\
    \ 'labels', {}))\n      if std.startsWith(lbl, prefix)\n    ];\n\n  if isIgnored(namespace)\
    \ || std.length(templateSetsFromLabel) < 1 then\n    []\n  else\n    std.set(templateSetsFromLabel);\n\
    \n// Generate from Templates.\nlocal generateTemplateMetadata(templateName, namespace)\
    \ =\n  config.templates[templateName] {\n    metadata+: {\n      namespace: namespace.metadata.name,\n\
    \    },\n  };\n\nlocal generateTemplate(templateName, namespace) =\n  generateTemplateMetadata(templateName,\
    \ namespace) {\n    metadata+: {\n      annotations: config.rbacAnnotations,\n\
    \      labels: config.rbacLabels,\n    },\n  } + config.templates[templateName];\n\
    \nlocal purgeTemplate(templateName, namespace) =\n  esp.markForDelete(generateTemplateMetadata(templateName,\
    \ namespace));\n\n// Reconcile the given namespace.\nlocal reconcileNamespace(namespace)\
    \ =\n  local desiredAvailableSets = std.set(std.filter(\n    function(template)\
    \ std.get(config.templates, template) != null,\n    std.flattenArrays([\n    \
    \  config.templateSets[set]\n      for set in desiredTemplateSets(namespace)\n\
    \      if std.get(config.templateSets, set) != null\n    ])\n  ));\n  // Generate\
    \ array of RbacPolicies for the given policy set.\n  [\n    generateTemplate(template,\
    \ namespace)\n    for template in desiredAvailableSets\n    // if cniMatches(policy)\
    \ \U0001F6A8 pretty sure can be removed\n  ]\n  // Generate array of RbacPolicies\
    \ to be deleted for the given policy set.\n  +\n  [\n    purgeTemplate(template,\
    \ namespace)\n    for template in std.setDiff(activeTemplateSets(namespace), desiredAvailableSets)\n\
    \    // if cniMatches(policy) \U0001F6A8 pretty sure can be removed\n  ]\n  //\
    \ Generate annotation for the given namespace containing the new active policy\
    \ sets.\n  +\n  [ {\n    apiVersion: 'v1',\n    kind: 'Namespace',\n    metadata:\
    \ {\n      annotations: {\n        [activeSetsAnnotation]: std.manifestJsonMinified(desiredAvailableSets),\n\
    \      },\n      name: namespace.metadata.name,\n    },\n  } ];\n\n// check if\
    \ the object is getting deleted by checking if it has\n// `metadata.deletionTimestamp`.\n\
    local inDelete(obj) = std.get(obj.metadata, 'deletionTimestamp', '') != '';\n\n\
    // Do the thing\nif esp.triggerName() == 'namespace' then (\n  // Handle single\
    \ namespace update on namespace trigger\n  local nsTrigger = esp.triggerData();\n\
    \  // nsTrigger.resource can be null if we're called when the namespace is getting\n\
    \  // deleted. If it's not null, we still don't want to do anything when the\n\
    \  // namespace is getting deleted.\n  if nsTrigger.resource != null && !inDelete(nsTrigger.resource)\
    \ then\n    reconcileNamespace(nsTrigger.resource)\n) else if esp.triggerName()\
    \ == 'role' || esp.triggerName() == 'rolebinding' then (\n  // Handle single namespace\
    \ update on role or rolebinding trigger\n  local namespace = esp.triggerData().resourceEvent.namespace;\n\
    \  std.flattenArrays([\n    reconcileNamespace(ns)\n    for ns in context.namespaces\n\
    \    if ns.metadata.name == namespace && !inDelete(ns)\n  ])\n) else (\n  // Reconcile\
    \ all namespaces for jsonnetlibrary update or managedresource\n  // reconcile.\n\
    \  local namespaces = context.namespaces;\n  std.flattenArrays([\n    reconcileNamespace(ns)\n\
    \    for ns in namespaces\n    if !inDelete(ns)\n  ])\n  +\n  legacyPolicyPurge\n\
    )\n"
  triggers:
    - name: jslib
      watchResource:
        apiVersion: espejote.io/v1alpha1
        kind: JsonnetLibrary
        name: espejote-rbac-sync
        namespace: syn-espejote
    - name: namespace
      watchContextResource:
        name: namespaces
    - name: role
      watchResource:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: Role
        labelSelector:
          matchLabels:
            app.kubernetes.io/component: rbac
            app.kubernetes.io/managed-by: espejote
            app.kubernetes.io/part-of: syn
        namespace: ''
    - name: rolebinding
      watchResource:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        labelSelector:
          matchLabels:
            app.kubernetes.io/component: rbac
            app.kubernetes.io/managed-by: espejote
            app.kubernetes.io/part-of: syn
        namespace: ''
